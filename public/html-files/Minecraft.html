<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Web Replica - Fixed Selection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 24px;
            height: 24px;
            margin-top: -12px;
            margin-left: -12px;
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before, #crosshair::after {
            content: "";
            position: absolute;
            background-color: rgba(255, 255, 255, 0.85);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
            border-radius: 1px;
        }
        #crosshair::before {
            width: 2px;
            height: 14px;
            left: 11px;
            top: 5px;
        }
        #crosshair::after {
            width: 14px;
            height: 2px;
            left: 5px;
            top: 11px;
        }
        /* Center dot for the crosshair */
        #crosshair-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            left: 10px;
            top: 10px;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }
        #inventory {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            border-radius: 5px;
            padding: 5px;
            z-index: 200;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background-color: rgba(80, 80, 80, 0.7);
            border: 2px solid #555;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.5);
        }
        .hotbar-slot::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0.05) 100%);
            z-index: -1;
        }
        .hotbar-slot.selected {
            border-color: #fffaaa;
            background-color: rgba(120, 120, 120, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3), inset 0 0 3px rgba(255, 255, 255, 0.3);
        }
        .hotbar-slot:hover {
            background-color: rgba(100, 100, 100, 0.8);
            border-color: #aaa;
            transform: translateY(-1px);
        }
        #hud {
            position: absolute;
            bottom: 5px;
            left: 5px;
            color: white;
            font-size: 14px;
            z-index: 100;
            text-shadow: 1px 1px 1px black;
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            text-shadow: 1px 1px 1px black;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #target-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            text-shadow: 1px 1px 1px black;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="crosshair">
        <div id="crosshair-dot"></div>
    </div>
    <div id="inventory">
        <div class="hotbar-slot selected" data-block="grass">Grass</div>
        <div class="hotbar-slot" data-block="dirt">Dirt</div>
        <div class="hotbar-slot" data-block="stone">Stone</div>
        <div class="hotbar-slot" data-block="wood">Wood</div>
        <div class="hotbar-slot" data-block="leaves">Leaves</div>
        <div class="hotbar-slot" data-block="sand">Sand</div>
        <div class="hotbar-slot" data-block="water">Water</div>
        <div class="hotbar-slot" data-block="glass">Glass</div>
        <div class="hotbar-slot" data-block="brick">Brick</div>
    </div>
    <div id="hud">
        <div>Position: <span id="position">0, 0, 0</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div>Block: <span id="block-type">Grass</span></div>
        <div>Blocks Rendered: <span id="blocks-rendered">0</span></div>
    </div>
    <div id="target-info">
        <div>Looking at: <span id="target-block">None</span></div>
        <div>Target face: <span id="target-face">None</span></div>
    </div>
    <div id="instructions">
        <h3>Minecraft Web Replica - Fixed Selection</h3>
        <p>WASD - Move around</p>
        <p>Space - Jump</p>
        <p>Left Click - Break block</p>
        <p>Right Click - Place block</p>
        <p>1-9 Keys - Select block type</p>
        <p>E - Toggle inventory visibility</p>
        <p>F - Toggle fly mode</p>
        <p>Click anywhere to lock pointer</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game setup
        const WORLD_SIZE = 32;
        const CHUNK_SIZE = 16;
        const BLOCK_SIZE = 1;
        
        // Initialization
        let scene, camera, renderer;
        let world = {};
        let worldData = {}; // Stores block types without rendering them
        let selectedBlock = 'grass';
        let raycaster, mouse;
        let highlightBox;
        let flyMode = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let renderedBlocksCount = 0;
        
        // Target information
        let targetBlockPosition = null;
        let targetFace = null;
        
        // Player physics
        const GRAVITY = 9.81;
        const JUMP_FORCE = 4;
        const PLAYER_SPEED = 5;
        const PLAYER_HEIGHT = 1.8;
        
        // Controls state
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            shift: false
        };

        // FPS counter
        let lastFrameTime = 0;
        let frameCount = 0;
        
        // Block types and textures
        const blockTypes = {
            grass: { 
                topColor: 0x4CBB17, // Brighter green for top
                sideColor: 0x8B7513, // Dirt with grass edge
                bottomColor: 0x8B4513, // Dirt color for bottom
                transparent: false,
                textured: true
            },
            dirt: { 
                color: 0x8B4513, 
                transparent: false,
                roughness: 0.9,
                textured: true
            },
            stone: { 
                color: 0x707070, 
                transparent: false,
                roughness: 0.8,
                textured: true
            },
            wood: { 
                topColor: 0x966F33, // Top/bottom rings
                sideColor: 0x8B5A2B, // Darker side
                transparent: false,
                textured: true
            },
            leaves: { 
                color: 0x2E8B57, 
                transparent: true, 
                opacity: 0.8,
                roughness: 0.8,
                textured: true
            },
            sand: { 
                color: 0xF5DEB3, 
                transparent: false,
                roughness: 1.0,
                textured: true
            },
            water: { 
                color: 0x1E90FF, 
                transparent: true, 
                opacity: 0.7,
                metalness: 0.2,
                roughness: 0.2
            },
            glass: { 
                color: 0xCFEFFF, 
                transparent: true, 
                opacity: 0.3,
                metalness: 0.9,
                roughness: 0.0
            },
            brick: { 
                color: 0xB22222, 
                transparent: false,
                roughness: 0.9,
                textured: true
            },
            air: { 
                color: 0xFFFFFF, 
                transparent: true, 
                opacity: 0 
            }
        };
        
        // Main initialization
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 20;
            camera.position.z = 5;
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Improved lighting for better block visuals
            const ambientLight = new THREE.AmbientLight(0xc2d1e6, 0.5); // Slightly blue ambient light
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xfffcda, 1.0); // Warm sunlight
            sunLight.position.set(100, 150, 50);
            sunLight.castShadow = true;
            
            // Improve shadow quality
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.bias = -0.0005;
            
            scene.add(sunLight);
            
            // Add a secondary light for better block definition
            const fillLight = new THREE.DirectionalLight(0xa9e1ff, 0.3); // Subtle blue fill light
            fillLight.position.set(-70, 30, -70);
            scene.add(fillLight);
            
            // Raycaster for block selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Enhanced highlight box for selected block
            const highlightGeometry = new THREE.BoxGeometry(BLOCK_SIZE + 0.03, BLOCK_SIZE + 0.03, BLOCK_SIZE + 0.03);
            
            // Create edges for a more defined selection box
            const edgesGeometry = new THREE.EdgesGeometry(highlightGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 2,
                transparent: true,
                opacity: 0.7
            });
            
            // Create a line segments object for the edges
            highlightBox = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            
            // Add a pulse animation effect
            highlightBox.pulse = 0;
            highlightBox.pulseDirection = 0.02;
            
            // Add an update function to the highlight box
            highlightBox.update = function(time) {
                // Pulse the opacity for a more dynamic effect
                this.pulse += this.pulseDirection;
                if (this.pulse > 1 || this.pulse < 0.4) {
                    this.pulseDirection *= -1;
                }
                
                this.material.opacity = 0.4 + (this.pulse * 0.3);
            };
            
            highlightBox.visible = false;
            scene.add(highlightBox);
            
            // Generate world
            generateTerrain();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            
            // Pointer lock for first-person controls
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    document.addEventListener('mousemove', onMouseMovePointerLock);
                } else {
                    document.removeEventListener('mousemove', onMouseMovePointerLock);
                }
            });
            
            // Select hotbar slots
            document.querySelectorAll('.hotbar-slot').forEach(slot => {
                slot.addEventListener('click', () => {
                    document.querySelector('.hotbar-slot.selected').classList.remove('selected');
                    slot.classList.add('selected');
                    selectedBlock = slot.getAttribute('data-block');
                    document.getElementById('block-type').textContent = slot.textContent;
                });
            });
            
            // Show inventory bar
            document.getElementById('inventory').style.display = 'flex';
            
            // Animation loop
            animate();
        }
        
        // Generate terrain with perlin noise-like function
        function generateTerrain() {
            // First, generate the terrain data without rendering
            for (let x = -WORLD_SIZE / 2; x < WORLD_SIZE / 2; x++) {
                for (let z = -WORLD_SIZE / 2; z < WORLD_SIZE / 2; z++) {
                    // Calculate height using a simple terrain function
                    const height = Math.floor(
                        Math.abs(Math.sin(x * 0.3) + Math.cos(z * 0.3)) * 3 + 3
                    );
                    
                    // Store block types without rendering
                    for (let y = 0; y < height; y++) {
                        let blockType;
                        if (y === height - 1) {
                            blockType = 'grass';
                        } else if (y > height - 4) {
                            blockType = 'dirt';
                        } else {
                            blockType = 'stone';
                        }
                        
                        setBlockData(x, y, z, blockType);
                    }
                    
                    // Generate water at y=1
                    if (height <= 1) {
                        setBlockData(x, 1, z, 'water');
                    }
                    
                    // Occasionally place trees
                    if (Math.random() < 0.02 && height > 1) {
                        generateTreeData(x, height, z);
                    }
                }
            }
            
            // Now, render only visible blocks
            renderVisibleBlocks();
        }
        
        // Generate tree data without rendering
        function generateTreeData(x, y, z) {
            // Tree trunk
            const trunkHeight = 4 + Math.floor(Math.random() * 3);
            for (let i = 0; i < trunkHeight; i++) {
                setBlockData(x, y + i, z, 'wood');
            }
            
            // Tree leaves
            for (let i = -2; i <= 2; i++) {
                for (let j = -2; j <= 2; j++) {
                    for (let k = -2; k <= 2; k++) {
                        if (Math.abs(i) + Math.abs(j) + Math.abs(k) <= 4) {
                            const leafX = x + i;
                            const leafY = y + trunkHeight + j;
                            const leafZ = z + k;
                            
                            // Don't override trunk blocks
                            if (getBlockData(leafX, leafY, leafZ) !== 'wood') {
                                setBlockData(leafX, leafY, leafZ, 'leaves');
                            }
                        }
                    }
                }
            }
        }
        
        // Only render blocks that are visible (have at least one face exposed to air or transparent block)
        function renderVisibleBlocks() {
            renderedBlocksCount = 0;
            
            // Check each block in worldData
            for (const key in worldData) {
                const [x, y, z] = key.split(',').map(Number);
                const blockType = worldData[key];
                
                // Skip air blocks
                if (blockType === 'air') {
                    continue;
                }
                
                // Check if block is visible
                if (isBlockVisible(x, y, z)) {
                    // Create mesh for this block
                    createBlockMesh(x, y, z, blockType);
                    renderedBlocksCount++;
                }
            }
            
            // Update the rendered blocks counter
            document.getElementById('blocks-rendered').textContent = renderedBlocksCount;
        }
        
        // Check if a block has at least one face exposed to air or a transparent block
        function isBlockVisible(x, y, z) {
            const directions = [
                {x: 1, y: 0, z: 0},   // Right
                {x: -1, y: 0, z: 0},  // Left
                {x: 0, y: 1, z: 0},   // Top
                {x: 0, y: -1, z: 0},  // Bottom
                {x: 0, y: 0, z: 1},   // Front
                {x: 0, y: 0, z: -1}   // Back
            ];
            
            for (const dir of directions) {
                const neighborType = getBlockData(x + dir.x, y + dir.y, z + dir.z);
                
                // If neighbor is air or a transparent block, this face is visible
                if (neighborType === 'air' || 
                    (blockTypes[neighborType] && blockTypes[neighborType].transparent)) {
                    return true;
                }
            }
            
            // No visible faces
            return false;
        }
        
        // Create a mesh for a block
        function createBlockMesh(x, y, z, type) {
            const blockInfo = blockTypes[type];
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            // Different materials for different block faces
            let materials = [];
            
            if (type === 'grass') {
                // Create materials for each face of grass block (top, sides, bottom)
                const topMaterial = createTexturedMaterial(blockInfo.topColor, blockInfo.transparent, blockInfo.opacity, 'grass-top');
                const sideMaterial = createTexturedMaterial(blockInfo.sideColor, blockInfo.transparent, blockInfo.opacity, 'grass-side');
                const bottomMaterial = createTexturedMaterial(blockInfo.bottomColor, blockInfo.transparent, blockInfo.opacity, 'dirt');
                
                // Order: right, left, top, bottom, front, back
                materials = [
                    sideMaterial, sideMaterial,
                    topMaterial,
                    bottomMaterial,
                    sideMaterial, sideMaterial
                ];
            } else if (type === 'wood') {
                // Create materials for wood (top/bottom ends and sides)
                const endMaterial = createTexturedMaterial(blockInfo.topColor, blockInfo.transparent, blockInfo.opacity, 'wood-end');
                const sideMaterial = createTexturedMaterial(blockInfo.sideColor, blockInfo.transparent, blockInfo.opacity, 'wood-side');
                
                // Order: right, left, top, bottom, front, back
                materials = [
                    sideMaterial, sideMaterial,
                    endMaterial,
                    endMaterial,
                    sideMaterial, sideMaterial
                ];
            } else {
                // Single material for other block types
                const material = createTexturedMaterial(
                    blockInfo.color, 
                    blockInfo.transparent, 
                    blockInfo.opacity || 1,
                    type
                );
                
                if (blockInfo.roughness !== undefined) {
                    material.roughness = blockInfo.roughness;
                }
                
                if (blockInfo.metalness !== undefined) {
                    material.metalness = blockInfo.metalness;
                }
                
                materials = Array(6).fill(material);
            }
            
            const mesh = new THREE.Mesh(geometry, materials);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add to scene and world object
            scene.add(mesh);
            
            // Store reference to mesh in world object
            const key = getBlockKey(x, y, z);
            world[key] = { type, mesh };
        }
        
        // Create a textured material based on block type
        function createTexturedMaterial(color, transparent, opacity, textureType) {
            const material = new THREE.MeshStandardMaterial({
                color: color,
                transparent: transparent,
                opacity: opacity || 1,
            });
            
            // Apply texture patterns based on block type
            switch (textureType) {
                case 'grass-top':
                    // Add noise to grass top
                    applyNoiseTexture(material, 0.2, 0.8, 0.3);
                    material.roughness = 0.9;
                    break;
                    
                case 'grass-side':
                    // Add a slight vertical gradient for grass side
                    material.roughness = 0.8;
                    break;
                    
                case 'dirt':
                    // Add dirt texture with noise
                    applyNoiseTexture(material, 0.4, 0.6, 0.8);
                    material.roughness = 0.9;
                    break;
                    
                case 'stone':
                    // Add stone texture with noise
                    applyNoiseTexture(material, 0.3, 0.7, 0.6);
                    material.roughness = 0.8;
                    break;
                    
                case 'wood-side':
                    // Add wood grain texture
                    material.roughness = 0.7;
                    break;
                    
                case 'wood-end':
                    // Add tree ring texture
                    material.roughness = 0.8;
                    break;
                    
                case 'leaves':
                    // Add leaf texture
                    applyNoiseTexture(material, 0.4, 0.7, 0.5);
                    material.roughness = 0.8;
                    break;
                    
                case 'sand':
                    // Add sand grain texture
                    applyNoiseTexture(material, 0.3, 0.6, 0.9);
                    material.roughness = 1.0;
                    break;
                    
                case 'brick':
                    // Add brick pattern
                    material.roughness = 0.9;
                    break;
                    
                default:
                    // No texture modifications
                    break;
            }
            
            return material;
        }
        
        // Apply a noise texture to the material to make it look more realistic
        function applyNoiseTexture(material, min, max, scale) {
            // We can't load external textures, but we can adjust material properties
            // to give the appearance of texture
            material.metalness = 0;
            material.roughness = scale;
            
            // Create a subtle random variation in the base color
            const baseColor = material.color.getHex();
            const r = ((baseColor >> 16) & 255) / 255;
            const g = ((baseColor >> 8) & 255) / 255;
            const b = (baseColor & 255) / 255;
            
            // Randomize the color slightly (subtle noise effect)
            const variation = min + Math.random() * (max - min);
            material.color.setRGB(
                r * variation,
                g * variation,
                b * variation
            );
        }
        
        // Data access functions
        function getBlockKey(x, y, z) {
            return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
        }
        
        // Get block type from worldData
        function getBlockData(x, y, z) {
            const key = getBlockKey(x, y, z);
            return worldData[key] || 'air';
        }
        
        // Get block type from rendered world
        function getBlock(x, y, z) {
            const key = getBlockKey(x, y, z);
            return world[key] ? world[key].type : getBlockData(x, y, z);
        }
        
        // Set block data without rendering
        function setBlockData(x, y, z, type) {
            const key = getBlockKey(x, y, z);
            
            // Don't do anything if the block is the same type
            if (worldData[key] === type) return;
            
            // If type is air, remove the data
            if (type === 'air') {
                delete worldData[key];
            } else {
                worldData[key] = type;
            }
        }
        
        // Set block in the world and update rendering
        function setBlock(x, y, z, type) {
            const key = getBlockKey(x, y, z);
            const oldType = getBlockData(x, y, z);
            
            // Update world data
            setBlockData(x, y, z, type);
            
            // If there's already a rendered block, remove it
            if (world[key] && world[key].mesh) {
                scene.remove(world[key].mesh);
                delete world[key];
                renderedBlocksCount--;
            }
            
            // If type is not air and block should be visible, create a new mesh
            if (type !== 'air' && isBlockVisible(x, y, z)) {
                createBlockMesh(x, y, z, type);
                renderedBlocksCount++;
            }
            
            // Update neighboring blocks
            const directions = [
                {x: 1, y: 0, z: 0},   // Right
                {x: -1, y: 0, z: 0},  // Left
                {x: 0, y: 1, z: 0},   // Top
                {x: 0, y: -1, z: 0},  // Bottom
                {x: 0, y: 0, z: 1},   // Front
                {x: 0, y: 0, z: -1}   // Back
            ];
            
            for (const dir of directions) {
                const nx = x + dir.x;
                const ny = y + dir.y;
                const nz = z + dir.z;
                const neighborKey = getBlockKey(nx, ny, nz);
                const neighborType = getBlockData(nx, ny, nz);
                
                // Skip air blocks
                if (neighborType === 'air') {
                    continue;
                }
                
                // Check if the neighbor should now be visible or hidden
                const shouldBeVisible = isBlockVisible(nx, ny, nz);
                const isCurrentlyRendered = !!world[neighborKey];
                
                if (shouldBeVisible && !isCurrentlyRendered) {
                    // Neighbor should be visible but isn't rendered yet
                    createBlockMesh(nx, ny, nz, neighborType);
                    renderedBlocksCount++;
                } else if (!shouldBeVisible && isCurrentlyRendered) {
                    // Neighbor shouldn't be visible but is currently rendered
                    scene.remove(world[neighborKey].mesh);
                    delete world[neighborKey];
                    renderedBlocksCount--;
                }
            }
            
            // Update the rendered blocks counter
            document.getElementById('blocks-rendered').textContent = renderedBlocksCount;
        }
        
        // Collision detection
        function checkCollision(position) {
            // Check blocks in a small area around the player
            for (let x = -1; x <= 1; x++) {
                for (let y = -2; y <= 2; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const blockX = Math.floor(position.x + x);
                        const blockY = Math.floor(position.y + y);
                        const blockZ = Math.floor(position.z + z);
                        
                        const blockType = getBlockData(blockX, blockY, blockZ);
                        if (blockType !== 'air' && blockType !== 'water' && blockType !== 'leaves') {
                            // Calculate simple collision box
                            const box = {
                                minX: blockX - BLOCK_SIZE / 2,
                                maxX: blockX + BLOCK_SIZE / 2,
                                minY: blockY - BLOCK_SIZE / 2,
                                maxY: blockY + BLOCK_SIZE / 2,
                                minZ: blockZ - BLOCK_SIZE / 2,
                                maxZ: blockZ + BLOCK_SIZE / 2
                            };
                            
                            // Check if player collides with this block
                            const playerRadius = 0.3;
                            if (position.x + playerRadius > box.minX && position.x - playerRadius < box.maxX &&
                                position.y > box.minY && position.y - PLAYER_HEIGHT < box.maxY &&
                                position.z + playerRadius > box.minZ && position.z - playerRadius < box.maxZ) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        // Check if player is on ground
        function isOnGround() {
            const feetY = camera.position.y - PLAYER_HEIGHT;
            // Check several points below player for more reliable ground detection
            for (let dx = -0.3; dx <= 0.3; dx += 0.3) {
                for (let dz = -0.3; dz <= 0.3; dz += 0.3) {
                    const blockType = getBlockData(
                        Math.floor(camera.position.x + dx),
                        Math.floor(feetY - 0.1),
                        Math.floor(camera.position.z + dz)
                    );
                    if (blockType !== 'air' && blockType !== 'water' && blockType !== 'leaves') {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Keyboard controls
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    keys.forward = true;
                    break;
                case 'KeyS':
                    keys.backward = true;
                    break;
                case 'KeyA':
                    keys.left = true;
                    break;
                case 'KeyD':
                    keys.right = true;
                    break;
                case 'Space':
                    keys.jump = true;
                    // Check ground status and apply jump immediately
                    if (isOnGround() || flyMode) {
                        velocity.y = JUMP_FORCE;
                    }
                    break;
                case 'KeyF':
                    flyMode = !flyMode;
                    velocity.y = 0; // Reset vertical velocity when toggling fly mode
                    break;
                case 'KeyE':
                    // Toggle inventory UI
                    const inventory = document.getElementById('inventory');
                    inventory.style.display = inventory.style.display === 'none' ? 'flex' : 'none';
                    break;
                case 'ShiftLeft':
                    keys.shift = true;
                    break;
            }
            
            // Hotbar selection
            if (event.code >= 'Digit1' && event.code <= 'Digit9') {
                const index = parseInt(event.code.replace('Digit', '')) - 1;
                const slots = document.querySelectorAll('.hotbar-slot');
                if (index < slots.length) {
                    document.querySelector('.hotbar-slot.selected').classList.remove('selected');
                    slots[index].classList.add('selected');
                    selectedBlock = slots[index].getAttribute('data-block');
                    document.getElementById('block-type').textContent = slots[index].textContent;
                }
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    keys.forward = false;
                    break;
                case 'KeyS':
                    keys.backward = false;
                    break;
                case 'KeyA':
                    keys.left = false;
                    break;
                case 'KeyD':
                    keys.right = false;
                    break;
                case 'Space':
                    keys.jump = false;
                    break;
                case 'ShiftLeft':
                    keys.shift = false;
                    break;
            }
        }
        
        // Mouse controls
        function onMouseMovePointerLock(event) {
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            // Use a consistent approach for camera rotation
            // Horizontal rotation (around global Y-axis)
            camera.rotation.y -= movementX * 0.002;
            
            // Vertical rotation (around local X-axis)
            const verticalRotation = camera.rotation.x - movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, verticalRotation));
            
            // Ensure the camera stays level with the horizon
            camera.rotation.z = 0;
            
            // Force camera to use proper order of rotations to avoid gimbal lock issues
            camera.rotation.order = 'YXZ';
        }
        
        // Mouse click for breaking and placing blocks
        function onMouseDown(event) {
            if (document.pointerLockElement !== renderer.domElement) return;
            
            // Use the already identified target block from updateTargetBlock()
            if (targetBlockPosition) {
                // Left click: remove block
                if (event.button === 0) {
                    setBlock(
                        targetBlockPosition.x,
                        targetBlockPosition.y,
                        targetBlockPosition.z,
                        'air'
                    );
                }
                // Right click: place block
                else if (event.button === 2) {
                    if (targetFace) {
                        // Calculate the position for the new block based on the targeted face
                        const placeX = targetBlockPosition.x + targetFace.x;
                        const placeY = targetBlockPosition.y + targetFace.y;
                        const placeZ = targetBlockPosition.z + targetFace.z;
                        
                        // Check if player is not inside the new block
                        const playerPos = camera.position.clone();
                        const playerBox = {
                            minX: playerPos.x - 0.3,
                            maxX: playerPos.x + 0.3,
                            minY: playerPos.y - PLAYER_HEIGHT,
                            maxY: playerPos.y + 0.3,
                            minZ: playerPos.z - 0.3,
                            maxZ: playerPos.z + 0.3
                        };
                        
                        const newBlockBox = {
                            minX: placeX - 0.5,
                            maxX: placeX + 0.5,
                            minY: placeY - 0.5,
                            maxY: placeY + 0.5,
                            minZ: placeZ - 0.5,
                            maxZ: placeZ + 0.5
                        };
                        
                        // Check for collision with player
                        if (!(playerBox.minX <= newBlockBox.maxX && playerBox.maxX >= newBlockBox.minX &&
                              playerBox.minY <= newBlockBox.maxY && playerBox.maxY >= newBlockBox.minY &&
                              playerBox.minZ <= newBlockBox.maxZ && playerBox.maxZ >= newBlockBox.minZ)) {
                            setBlock(placeX, placeY, placeZ, selectedBlock);
                        }
                    }
                }
            }
            
            // Prevent context menu on right click
            if (event.button === 2) {
                event.preventDefault();
            }
        }
        
        // IMPROVED: Update target block and face based on crosshair position
        function updateTargetBlock() {
            // Reset targets
            targetBlockPosition = null;
            targetFace = null;
            highlightBox.visible = false;
            
            // Only highlight when pointer is locked
            if (document.pointerLockElement !== renderer.domElement) {
                updateTargetInfo("None", "None");
                return;
            }
            
            // Cast ray from camera center (where the crosshair is)
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // Get the direction the camera is facing
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // Search along the ray for a block
            const maxDistance = 5; // Maximum reach
            const step = 0.05;    // Smaller step for more precision
            
            // Initialize previous position for face detection
            let previousPosition = camera.position.clone();
            
            for (let distance = 0; distance <= maxDistance; distance += step) {
                const position = camera.position.clone().addScaledVector(direction, distance);
                
                const blockX = Math.floor(position.x);
                const blockY = Math.floor(position.y);
                const blockZ = Math.floor(position.z);
                
                const blockType = getBlockData(blockX, blockY, blockZ);
                
                // If we found a non-air block
                if (blockType !== 'air') {
                    targetBlockPosition = new THREE.Vector3(blockX, blockY, blockZ);
                    
                    // Find which face we hit by comparing the current position with the previous position
                    // This gives us the exact face we're looking at
                    const dx = previousPosition.x - position.x;
                    const dy = previousPosition.y - position.y;
                    const dz = previousPosition.z - position.z;
                    
                    // Find the largest component to determine which face was hit
                    const absX = Math.abs(dx);
                    const absY = Math.abs(dy);
                    const absZ = Math.abs(dz);
                    
                    if (absX >= absY && absX >= absZ) {
                        targetFace = new THREE.Vector3(Math.sign(dx), 0, 0);
                    } else if (absY >= absX && absY >= absZ) {
                        targetFace = new THREE.Vector3(0, Math.sign(dy), 0);
                    } else {
                        targetFace = new THREE.Vector3(0, 0, Math.sign(dz));
                    }
                    
                    // Show highlight box
                    highlightBox.position.set(blockX, blockY, blockZ);
                    highlightBox.visible = true;
                    
                    // Update target info display
                    updateTargetInfo(blockType, getFaceName(targetFace));
                    
                    return;
                }
                
                // Store this position for the next iteration
                previousPosition = position.clone();
            }
            
            // If we get here, no block was found
            updateTargetInfo("None", "None");
        }
        
        // Helper function to get face name from face vector
        function getFaceName(faceVector) {
            if (!faceVector) return "None";
            
            if (faceVector.x > 0) return "West";
            if (faceVector.x < 0) return "East";
            if (faceVector.y > 0) return "Bottom";
            if (faceVector.y < 0) return "Top";
            if (faceVector.z > 0) return "North";
            if (faceVector.z < 0) return "South";
            
            return "Unknown";
        }
        
        // Update the target info display
        function updateTargetInfo(blockType, faceName) {
            document.getElementById('target-block').textContent = blockType;
            document.getElementById('target-face').textContent = faceName;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); // Convert to seconds, cap at 0.1 to prevent huge jumps
            
            // Update FPS counter
            frameCount++;
            if (time - lastFrameTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = time;
            }
            
            // Update position display
            document.getElementById('position').textContent = 
                `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
            
            // IMPROVED: Update target block before movement
            updateTargetBlock();
            
            // Movement logic
            const onGround = isOnGround();
            
            if (flyMode) {
                // Flying movement
                velocity.y = 0; // Reset gravity in fly mode
                
                if (keys.jump) velocity.y = PLAYER_SPEED;
                if (keys.shift) velocity.y = -PLAYER_SPEED;
                
                // Move in camera direction
                direction.z = Number(keys.forward) - Number(keys.backward);
                direction.x = Number(keys.right) - Number(keys.left);
                direction.normalize();
                
                // Adjust for camera rotation
                if (direction.z !== 0 || direction.x !== 0) {
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(camera.rotation.y);
                    direction.applyMatrix4(rotationMatrix);
                    
                    velocity.x = direction.x * PLAYER_SPEED;
                    velocity.z = direction.z * PLAYER_SPEED;
                } else {
                    velocity.x = 0;
                    velocity.z = 0;
                }
            } else {
                // Apply gravity
                if (!onGround) {
                    velocity.y -= GRAVITY * delta;
                } else if (velocity.y < 0) {
                    velocity.y = 0;
                }
                
                // Movement direction - negative Z is forward in Three.js
                direction.z = Number(keys.backward) - Number(keys.forward); // Inverted to match Minecraft controls
                direction.x = Number(keys.right) - Number(keys.left);
                
                // Only move in XZ plane (no flying)
                if (direction.z !== 0 || direction.x !== 0) {
                    direction.normalize();
                    
                    // Rotate movement direction based on camera rotation
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(camera.rotation.y);
                    direction.applyMatrix4(rotationMatrix);
                    
                    velocity.x = direction.x * PLAYER_SPEED;
                    velocity.z = direction.z * PLAYER_SPEED;
                } else {
                    // Apply friction
                    velocity.x *= 0.8;
                    velocity.z *= 0.8;
                    
                    if (Math.abs(velocity.x) < 0.01) velocity.x = 0;
                    if (Math.abs(velocity.z) < 0.01) velocity.z = 0;
                }
            }
            
            // Move player with collision detection
            const newPosition = camera.position.clone();
            
            // Try X movement
            newPosition.x += velocity.x * delta;
            if (!checkCollision(newPosition)) {
                camera.position.x = newPosition.x;
            } else {
                velocity.x = 0; // Stop X movement on collision
                newPosition.x = camera.position.x; // Reset for Y and Z checks
            }
            
            // Try Y movement
            newPosition.y += velocity.y * delta;
            if (!checkCollision(newPosition)) {
                camera.position.y = newPosition.y;
            } else {
                velocity.y = 0; // Stop Y movement on collision
                newPosition.y = camera.position.y; // Reset for Z check
            }
            
            // Try Z movement
            newPosition.z += velocity.z * delta;
            if (!checkCollision(newPosition)) {
                camera.position.z = newPosition.z;
            } else {
                velocity.z = 0; // Stop Z movement on collision
            }
            
            // Update highlight box pulse animation
            if (highlightBox.visible) {
                highlightBox.update(time);
            }
            
            // Render scene
            renderer.render(scene, camera);
            
            prevTime = time;
        }
        
        // Prevent context menu on right click
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Start the game
        init();
    </script>
</body>
</html>
